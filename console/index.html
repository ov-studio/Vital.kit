<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8"/>
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
        <title>Console</title>
        <link rel="preconnect" href="https://fonts.googleapis.com"/>
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Geist+Mono:wght@400;500;600;700&family=Geist:wght@400;500;600;700&display=swap"/>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ov-studio/Vital.kit@main/console/index.css"/>
    </head>

    <body>
        <!-- React -->
        <div id="root"></div>
        <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"/>
        <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"/>
        <script src="https://unpkg.com/@babel/standalone/babel.min.js"/>
        <script type="text/babel" src="https://cdn.jsdelivr.net/gh/ov-studio/Vital.kit@main/console/index.js"/>

        <script type="text/babel">
            const Console = () => {
                // State
                const [logs, set_logs] = useState([]);
                const [command_input, set_command_input] = useState('');
                const [is_dragging, set_is_dragging] = useState(false);

                // Command history state
                const [command_history, set_command_history] = useState([]);
                const [history_index, set_history_index] = useState(-1);
                const [temp_input, set_temp_input] = useState('');

                // Get all level types sorted by priority
                const level_types = useMemo(() => get_sorted_level_types(), []);

                // Initialize active filters with all level types
                const [active_filters, set_active_filters] = useState(new Set(level_types));
                const [position, set_position] = useState({ x: 0, y: 0 });
                const [size, set_size] = useState({ width: '800px', height: '360px' });

                // Refs
                const console_ref = useRef(null);
                const log_body_ref = useRef(null);
                const input_ref = useRef(null);
                const group_map_ref = useRef(new Map());
                const drag_offset_ref = useRef({ x: 0, y: 0 });

                // Calculate counts
                const log_counts = useMemo(() => {
                    const counts = {};
                    level_types.forEach(type => counts[type] = 0);
                    logs.forEach(log => {
                        if (counts[log.type] !== undefined) {
                            counts[log.type]++;
                        }
                    });
                    return counts;
                }, [logs, level_types]);

                const total_count = useMemo(() =>
                    Object.values(log_counts).reduce((sum, count) => sum + count, 0),
                    [log_counts]
                );

                // Log Management
                const add_log = useCallback((type, message, timestamp = null) => {
                    // Skip if type is not valid
                    if (!type || !message || !LEVELS[type]) return;

                    const ts = timestamp || new Date().toTimeString().slice(0, 8);
                    const now = Date.now();
                    const key = make_key(type, message);

                    // Clean expired groups
                    for (const [k, entry] of group_map_ref.current) {
                        if (now >= entry.expires_at) {
                            group_map_ref.current.delete(k);
                        }
                    }

                    const existing = group_map_ref.current.get(key);

                    if (existing) {
                        // Update existing log
                        existing.count++;
                        existing.expires_at = now + GROUP_MS;
                        existing.timestamp = ts;

                        set_logs(prev_logs =>
                            prev_logs.map(log =>
                                log.id === existing.id
                                    ? { ...log, repeat_count: existing.count, timestamp: ts }
                                    : log
                            )
                        );

                        // Auto-scroll if at bottom
                        setTimeout(() => {
                            const log_el = log_body_ref.current;
                            if (log_el) {
                                const at_bottom = log_el.scrollHeight - log_el.scrollTop - log_el.clientHeight < 6;
                                if (at_bottom) log_el.scrollTop = log_el.scrollHeight;
                            }
                        }, 0);
                    }
                    else {
                        // Add new log
                        const new_log = {
                            id: Date.now() + Math.random(),
                            type,
                            message,
                            timestamp: ts,
                            repeat_count: 1
                        };

                        group_map_ref.current.set(key, {
                            id: new_log.id,
                            count: 1,
                            expires_at: now + GROUP_MS,
                            timestamp: ts
                        });

                        set_logs(prev_logs => [...prev_logs, new_log]);

                        // Auto-scroll to bottom
                        setTimeout(() => {
                            const log_el = log_body_ref.current;
                            if (log_el) log_el.scrollTop = log_el.scrollHeight;
                        }, 0);
                    }
                }, []);

                const clear_logs = useCallback(() => {
                    set_logs([]);
                    group_map_ref.current.clear();
                }, []);

                // Message Handler
                const handle_message = useCallback((e) => {
                    var data = JSON.parse(e.detail);
                    if (data.action === 'print') {
                        add_log(data.mode, data.message);
                    }
                }, [add_log]);

                // Command Handler
                const handle_command = useCallback((command) => {
                    const trimmed = command.trim();
                    if (trimmed === '') return;

                    const message = trimmed
                        .split(/\s+/)           // split by one or more spaces
                        .filter(Boolean);       // extra safety (removes empty strings)

                    // Add to history (avoid duplicates of the last command)
                    set_command_history(prev => {
                        if (prev.length === 0 || prev[prev.length - 1] !== trimmed) {
                            return [...prev, trimmed];
                        }
                        return prev;
                    });

                    // Reset history navigation
                    set_history_index(-1);
                    set_temp_input('');

                    ipc.postMessage(
                        JSON.stringify({
                            action: "command",
                            message: message
                        })
                    );
                }, []);

                const handle_key_down = useCallback((e) => {
                    // Only handle arrow keys when input is focused
                    if (e.target !== input_ref.current) return;

                    if (e.key === 'Enter' && command_input.trim() !== '') {
                        handle_command(command_input);
                        set_command_input('');
                    }
                    else if (e.key === 'ArrowUp') {
                        e.preventDefault();

                        if (command_history.length === 0) return;

                        // Save current input when starting to navigate history
                        if (history_index === -1) {
                            set_temp_input(command_input);
                        }

                        const new_index = history_index === -1
                            ? command_history.length - 1
                            : Math.max(0, history_index - 1);

                        set_history_index(new_index);
                        set_command_input(command_history[new_index]);
                    }
                    else if (e.key === 'ArrowDown') {
                        e.preventDefault();

                        if (history_index === -1) return;

                        const new_index = history_index + 1;

                        if (new_index >= command_history.length) {
                            // Back to the temp input (what user was typing)
                            set_history_index(-1);
                            set_command_input(temp_input);
                        }
                        else {
                            set_history_index(new_index);
                            set_command_input(command_history[new_index]);
                        }
                    }
                }, [command_input, command_history, history_index, temp_input, handle_command]);

                // Filter Management
                const toggle_filter = useCallback((type) => {
                    if (type === 'all') {
                        // Toggle: if all are currently active, turn all off, otherwise turn all on
                        if (active_filters.size === level_types.length) set_active_filters(new Set());
                        else set_active_filters(new Set(level_types));
                    }
                    else {
                        set_active_filters(prev => {
                            const new_filters = new Set(prev);
                            if (new_filters.has(type)) new_filters.delete(type);
                            else new_filters.add(type);
                            return new_filters;
                        });
                    }
                }, [level_types, active_filters.size]);

                // Position Management
                const reset_position = useCallback(() => {
                    set_position({ x: 0, y: 0 });
                }, []);

                // Drag Handlers
                const handle_mouse_down = useCallback((e) => {
                    if (e.target.closest('.icon-btn, .filter')) return;
                    e.preventDefault();
                    set_is_dragging(true);

                    const rect = console_ref.current.getBoundingClientRect();
                    drag_offset_ref.current = {
                        x: e.clientX - rect.left,
                        y: e.clientY - rect.top
                    };
                }, []);

                const handle_mouse_move = useCallback((e) => {
                    if (!is_dragging) return;
                    set_position({
                        x: e.clientX - drag_offset_ref.current.x,
                        y: e.clientY - drag_offset_ref.current.y
                    });
                }, [is_dragging]);

                const handle_mouse_up = useCallback(() => {
                    set_is_dragging(false);
                }, []);

                // Resize Handlers
                const handle_resize_start = useCallback((e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    const start_x = e.clientX;
                    const start_y = e.clientY;
                    const rect = console_ref.current.getBoundingClientRect();
                    const start_width = rect.width;
                    const start_height = rect.height;

                    const handle_resize_move = (e) => {
                        const new_width = Math.max(400, start_width + e.clientX - start_x);
                        const new_height = Math.max(260, start_height + e.clientY - start_y);
                        set_size({ width: new_width + 'px', height: new_height + 'px' });
                    };

                    const handle_resize_end = () => {
                        document.removeEventListener('mousemove', handle_resize_move);
                        document.removeEventListener('mouseup', handle_resize_end);
                    };

                    document.addEventListener('mousemove', handle_resize_move);
                    document.addEventListener('mouseup', handle_resize_end);
                }, []);

                // Prevent context menu
                useEffect(() => {
                    const prevent_context = (e) => e.preventDefault();
                    document.addEventListener('contextmenu', prevent_context);
                    return () => document.removeEventListener('contextmenu', prevent_context);
                }, []);

                // Drag event listeners
                useEffect(() => {
                    if (is_dragging) {
                        document.addEventListener('mousemove', handle_mouse_move);
                        document.addEventListener('mouseup', handle_mouse_up);
                        return () => {
                            document.removeEventListener('mousemove', handle_mouse_move);
                            document.removeEventListener('mouseup', handle_mouse_up);
                        };
                    }
                }, [is_dragging, handle_mouse_move, handle_mouse_up]);

                // Message listeners
                useEffect(() => {
                    document.addEventListener('message', handle_message);
                    return () => document.removeEventListener('message', handle_message);
                }, [handle_message]);

                // Render
                return (
                    <div
                        ref={console_ref}
                        className="console"
                        style={{
                            left: `${position.x}px`,
                            top: `${position.y}px`,
                            width: size.width,
                            height: size.height
                        }}
                    >
                        {/* Header */}
                        <div className={`header ${is_dragging ? 'dragging' : ''}`} onMouseDown={handle_mouse_down}>
                            <span className="titlebar-label">Console</span>
                            <div className="header-divider"></div>

                            {/* Filters - Auto-generated */}
                            <div className="filters">
                                <FilterButton
                                    type="all"
                                    label="All"
                                    count={total_count}
                                    is_active={active_filters.size === level_types.length}
                                    on_click={() => toggle_filter('all')}
                                />
                                {level_types.map(type => (
                                    <FilterButton
                                        key={type}
                                        type={type}
                                        label={LEVELS[type].label}
                                        count={log_counts[type]}
                                        is_active={active_filters.has(type)}
                                        on_click={() => toggle_filter(type)}
                                        label_color={LEVELS[type].label_color}
                                        bg_color={LEVELS[type].bg_color}
                                    />
                                ))}
                            </div>

                            {/* Actions */}
                            <div className="tabbar-actions">
                                <ActionButton icon={RotateCcw} label="Reset" on_click={reset_position}/>
                                <ActionButton icon={Trash2} label="Clear" on_click={clear_logs}/>
                            </div>
                        </div>

                        {/* Log Body */}
                        <div ref={log_body_ref} className="log-body">
                            {logs.map(log => (
                                <LogRow
                                    key={log.id}
                                    type={log.type}
                                    timestamp={log.timestamp}
                                    message={log.message}
                                    repeat_count={log.repeat_count}
                                    is_hidden={!active_filters.has(log.type)}
                                />
                            ))}
                        </div>

                        {/* Input Bar */}
                        <div className="input-bar">
                            <span className="input-prompt">‚ùØ</span>
                            <input
                                ref={input_ref}
                                className="input-field"
                                value={command_input}
                                onChange={(e) => set_command_input(e.target.value)}
                                onKeyDown={handle_key_down}
                                placeholder="Enter command or expression..."
                                autoComplete="off"
                                spellCheck="false"
                            />
                        </div>

                        {/* Resize Handle */}
                        <div className="resize-handle" onMouseDown={handle_resize_start}>
                            <span></span>
                        </div>
                    </div>
                );
            };

            // RENDER APP
            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(<Console/>);
        </script>
    </body>
</html>